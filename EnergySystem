import os
import re
from datetime import datetime
from glob import glob

import numpy as np
import pandas as pd
from openpyxl import Workbook, load_workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.utils import get_column_letter

import tkinter as tk
from tkinter import ttk, messagebox

# Calendar for Daily Entry tab (optional)
try:
    from tkcalendar import DateEntry
    HAS_TKCAL = True
except Exception:
    HAS_TKCAL = False

# Pillow for logo in Excel (optional)
try:
    from PIL import Image
    HAS_PIL = True
except Exception:
    HAS_PIL = False


# ---------------------------
# Paths / Settings
# ---------------------------
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

MACHINES_FOLDER = os.path.join(BASE_DIR, "Machines sheet")
MACHINES_FILE = os.path.join(MACHINES_FOLDER, "Machines.xlsx")

REPORT_FOLDER = os.path.join(BASE_DIR, "Daily Meter Reading Report")
MONTHLY_REPORT_FOLDER = os.path.join(BASE_DIR, "Monthly Meter Reading Report")
ONLY_REPORT_FOLDER = os.path.join(REPORT_FOLDER, "Only_Meter_Reading")
ELECTRICIANS_REPORT_FOLDER = os.path.join(REPORT_FOLDER, "Daily_Electricians_Meter_Reading")

os.makedirs(REPORT_FOLDER, exist_ok=True)
os.makedirs(MACHINES_FOLDER, exist_ok=True)
os.makedirs(MONTHLY_REPORT_FOLDER, exist_ok=True)
os.makedirs(ONLY_REPORT_FOLDER, exist_ok=True)
os.makedirs(ELECTRICIANS_REPORT_FOLDER, exist_ok=True)

LOGO_PATH = os.path.join(BASE_DIR, "Images", "logo.jpg")  # change if needed

DATE_RE = re.compile(r"^\d{4}-\d{2}-\d{2}$")
REPORT_FILE_RE = re.compile(r"Daily_Meter_Reading_Report_(\d{4}-\d{2}-\d{2})\.xlsx$")
MONTH_RE = re.compile(r"^\d{4}-\d{2}$")

DEPARTMENTS = ["1st Mixing", "Rolling", "Curing", "Air compressor", "Other"]
VIEW_DEPARTMENTS = ["All"] + DEPARTMENTS

M_HEADERS = ["PMNo", "MachineName", "Department"]
DAILY_HEADERS = [
    "PMNo",
    "MachineName",
    "Department",
    "Prev_kWh",
    "Today_kWh",
    "Daily_Use",
    "Avg_Daily",
    "%_vs_Avg",
    "Notes",
]
SIMPLE_HEADERS = ["PMNo", "MachineName", "Today_kWh"]
ELECTRICIANS_PMNOS = ["PM 01", "PM 1", "PM 32", "PM 19"]

DECIMALS = 4

# Cache for history to improve performance
_HISTORY_CACHE = None
_HISTORY_CACHE_SIG = None  # (newest_mtime, file_count)


# ---------------------------
# Helpers: Machines Master
# ---------------------------

def _normalize_department(value: str) -> str:
    value = (value or "").strip()
    return value if value in DEPARTMENTS else "Other"


def _autosize_machines_sheet(ws):
    widths = {}
    for row in ws.iter_rows():
        for cell in row:
            value = "" if cell.value is None else str(cell.value)
            widths[cell.column_letter] = max(widths.get(cell.column_letter, 0), len(value))

    for col_letter, length in widths.items():
        if col_letter == "A":
            width = max(12, min(18, length + 4))
        elif col_letter == "B":
            width = max(30, min(48, length + 6))
        elif col_letter == "C":
            width = max(18, min(28, length + 6))
        else:
            width = max(12, min(30, length + 4))
        ws.column_dimensions[col_letter].width = width


def ensure_machines_file():
    if not os.path.exists(MACHINES_FILE):
        wb = Workbook()
        ws = wb.active
        ws.title = "Machines"
        ws.append(M_HEADERS)
        _autosize_machines_sheet(ws)
        wb.save(MACHINES_FILE)
        return

    wb = load_workbook(MACHINES_FILE)
    ws = wb.active
    headers = [str(ws.cell(row=1, column=i).value or "").strip() for i in range(1, ws.max_column + 1)]
    if "Department" not in headers:
        ws.cell(row=1, column=ws.max_column + 1, value="Department")
        for r in range(2, ws.max_row + 1):
            ws.cell(row=r, column=ws.max_column, value="Other")
        _autosize_machines_sheet(ws)
        wb.save(MACHINES_FILE)


def load_machines_df():
    ensure_machines_file()
    df = pd.read_excel(MACHINES_FILE, sheet_name="Machines")
    if df.empty:
        return pd.DataFrame(columns=M_HEADERS)

    df["PMNo"] = df["PMNo"].astype(str).str.strip()
    df["MachineName"] = df["MachineName"].astype(str).str.strip()
    if "Department" not in df.columns:
        df["Department"] = "Other"
    df["Department"] = df["Department"].astype(str).apply(_normalize_department)
    df = df[(df["PMNo"] != "") & (df["MachineName"] != "")]
    return df[M_HEADERS].copy()


def add_machine(pmno: str, name: str, department: str):
    pmno = (pmno or "").strip()
    name = (name or "").strip()
    department = _normalize_department(department)
    if not pmno or not name:
        raise ValueError("PM No and Machine Name are required.")

    df = load_machines_df()
    if not df.empty and (df["PMNo"].str.upper() == pmno.upper()).any():
        raise ValueError("This PM No already exists.")

    wb = load_workbook(MACHINES_FILE)
    ws = wb["Machines"]
    ws.append([pmno, name, department])
    _autosize_machines_sheet(ws)
    wb.save(MACHINES_FILE)


def delete_machine(pmno: str):
    pmno = (pmno or "").strip()
    if not pmno:
        raise ValueError("PM No is required.")

    ensure_machines_file()
    wb = load_workbook(MACHINES_FILE)
    ws = wb["Machines"]

    target_row = None
    for r in range(2, ws.max_row + 1):
        v = ws.cell(row=r, column=1).value
        if v is None:
            continue
        if str(v).strip().upper() == pmno.upper():
            target_row = r
            break

    if target_row is None:
        raise ValueError("PM No not found.")

    ws.delete_rows(target_row, 1)
    _autosize_machines_sheet(ws)
    wb.save(MACHINES_FILE)


# ---------------------------
# Helpers: Reports
# ---------------------------

def list_report_dates():
    dates = []
    for fp in glob(os.path.join(REPORT_FOLDER, "Daily_Meter_Reading_Report_*.xlsx")):
        name = os.path.basename(fp)
        m = REPORT_FILE_RE.match(name)
        if m and DATE_RE.match(m.group(1)):
            dates.append(m.group(1))
    dates.sort()
    return dates


def list_report_months():
    months = set()
    for d in list_report_dates():
        months.add(d[:7])
    return sorted(months)


def report_path(day_str: str):
    return os.path.join(REPORT_FOLDER, f"Daily_Meter_Reading_Report_{day_str}.xlsx")


def simple_report_path(day_str: str):
    return os.path.join(ONLY_REPORT_FOLDER, f"Only_Meter_Reading_{day_str}.xlsx")


def electricians_report_path(day_str: str):
    return os.path.join(ELECTRICIANS_REPORT_FOLDER, f"Electricians_Meter_Reading_{day_str}.xlsx")


def monthly_report_path(month_str: str):
    return os.path.join(MONTHLY_REPORT_FOLDER, f"Monthly_Meter_Reading_Report_{month_str}.xlsx")


def safe_date_str(s: str) -> str:
    s = (s or "").strip()
    datetime.strptime(s, "%Y-%m-%d")
    return s


def safe_month_str(s: str) -> str:
    s = (s or "").strip()
    if not MONTH_RE.match(s):
        try:
            dt = datetime.strptime(s, "%Y-%m-%d")
            return dt.strftime("%Y-%m")
        except Exception:
            raise ValueError("Month must be YYYY-MM (example: 2026-01)")
    return s


def month_date_list(month_str: str):
    month_str = safe_month_str(month_str)
    start_dt = pd.to_datetime(month_str + "-01")
    end_dt = (start_dt + pd.offsets.MonthBegin(1))
    days = pd.date_range(start=start_dt, end=end_dt - pd.Timedelta(days=1), freq="D")
    return [d.to_pydatetime().date() for d in days]


def read_report_table(day_str: str) -> pd.DataFrame:
    fp = report_path(day_str)
    if not os.path.exists(fp):
        return pd.DataFrame(columns=DAILY_HEADERS)

    wb = load_workbook(fp, data_only=True)
    if "Report" not in wb.sheetnames:
        return pd.DataFrame(columns=DAILY_HEADERS)

    ws = wb["Report"]

    header_row = 10
    headers = [str(ws.cell(row=header_row, column=c).value or "").strip() for c in range(1, 10)]
    if headers[:2] != ["PMNo", "MachineName"]:
        return pd.DataFrame(columns=DAILY_HEADERS)

    rows = []
    r = header_row + 1
    empty_count = 0
    max_scan = 5000
    while empty_count < 10 and r < header_row + max_scan:
        pm = ws.cell(row=r, column=1).value
        if pm is None or str(pm).strip() == "":
            empty_count += 1
            r += 1
            continue
        empty_count = 0
        row = [ws.cell(row=r, column=c).value for c in range(1, 10)]
        rows.append(row)
        r += 1

    df = pd.DataFrame(rows, columns=headers)
    if "Department" not in df.columns:
        df.insert(2, "Department", "Other")
    for col in DAILY_HEADERS:
        if col not in df.columns:
            df[col] = None
    df = df[DAILY_HEADERS].copy()

    machines = load_machines_df()
    if not machines.empty:
        dept_map = dict(zip(machines["PMNo"], machines["Department"]))
        df["Department"] = df["PMNo"].map(dept_map).fillna(df["Department"]).apply(_normalize_department)

    df["PMNo"] = df["PMNo"].astype(str).str.strip()
    df["MachineName"] = df["MachineName"].astype(str).str.strip()
    for c in ["Prev_kWh", "Today_kWh", "Daily_Use", "Avg_Daily", "%_vs_Avg"]:
        df[c] = pd.to_numeric(df[c], errors="coerce")
    df["Notes"] = df["Notes"].fillna("").astype(str).replace(["nan", "None"], "")
    df["Department"] = df["Department"].astype(str).apply(_normalize_department)
    return df


def read_electricians_report(day_str: str) -> pd.DataFrame:
    fp = electricians_report_path(day_str)
    if not os.path.exists(fp):
        return pd.DataFrame(columns=SIMPLE_HEADERS)

    try:
        df = pd.read_excel(fp, sheet_name="Electricians")
    except Exception:
        return pd.DataFrame(columns=SIMPLE_HEADERS)

    for col in SIMPLE_HEADERS:
        if col not in df.columns:
            df[col] = None
    df = df[SIMPLE_HEADERS].copy()
    df["PMNo"] = df["PMNo"].astype(str).str.strip()
    df["MachineName"] = df["MachineName"].astype(str).str.strip()
    df["Today_kWh"] = pd.to_numeric(df["Today_kWh"], errors="coerce")
    return df


def build_history_from_reports():
    global _HISTORY_CACHE, _HISTORY_CACHE_SIG

    files = glob(os.path.join(REPORT_FOLDER, "Daily_Meter_Reading_Report_*.xlsx"))
    newest = max([os.path.getmtime(f) for f in files], default=0)
    sig = (newest, len(files))

    if _HISTORY_CACHE is not None and _HISTORY_CACHE_SIG == sig:
        return _HISTORY_CACHE.copy()

    dates = list_report_dates()
    chunks = []
    for d in dates:
        df = read_report_table(d)
        if df.empty:
            continue
        tmp = df[["PMNo", "MachineName", "Department", "Today_kWh"]].copy()
        tmp["Date"] = pd.to_datetime(d)
        tmp["PMNo"] = tmp["PMNo"].astype(str).str.strip()
        tmp["MachineName"] = tmp["MachineName"].astype(str).str.strip()
        tmp["Department"] = tmp["Department"].astype(str).apply(_normalize_department)
        tmp["Today_kWh"] = pd.to_numeric(tmp["Today_kWh"], errors="coerce")
        tmp = tmp.dropna(subset=["Today_kWh"])
        chunks.append(tmp)

    if not chunks:
        _HISTORY_CACHE = pd.DataFrame(columns=["Date", "PMNo", "MachineName", "Department", "Today_kWh"])
    else:
        _HISTORY_CACHE = pd.concat(chunks, ignore_index=True).sort_values(["PMNo", "Date"])

    _HISTORY_CACHE_SIG = sig
    return _HISTORY_CACHE.copy()


def compute_prev_and_avg_maps(day_str: str):
    hist = build_history_from_reports()
    day_dt = pd.to_datetime(day_str)

    prev_map, avg_map = {}, {}
    if hist.empty:
        return prev_map, avg_map

    before = hist[hist["Date"] < day_dt].sort_values(["PMNo", "Date"]).groupby("PMNo").tail(1)
    prev_map = dict(zip(before["PMNo"], before["Today_kWh"]))

    hist2 = hist.copy()
    hist2["Prev"] = hist2.groupby("PMNo")["Today_kWh"].shift(1)
    hist2["DailyUse"] = hist2["Today_kWh"] - hist2["Prev"]
    hist2.loc[hist2["DailyUse"] < 0, "DailyUse"] = np.nan
    avg_map = hist2.groupby("PMNo")["DailyUse"].mean().to_dict()

    return prev_map, avg_map


# ---------------------------
# Daily Report Writer
# ---------------------------

def write_professional_report(day_str: str, df: pd.DataFrame):
    machine_count = int(len(df))
    readings_entered = int(pd.to_numeric(df["Today_kWh"], errors="coerce").notna().sum())
    total_use = float(pd.to_numeric(df["Daily_Use"], errors="coerce").fillna(0).sum())

    wb = Workbook()
    ws = wb.active
    ws.title = "Report"

    col_widths = [14, 36, 20, 14, 14, 16, 16, 14, 30]
    for i, w in enumerate(col_widths, start=1):
        ws.column_dimensions[get_column_letter(i)].width = w

    title_fill = PatternFill("solid", fgColor="1F4E79")
    title_font = Font(name="Segoe UI", size=16, bold=True, color="FFFFFF")
    label_font = Font(name="Segoe UI", size=11, bold=True)
    value_font = Font(name="Segoe UI", size=11)
    header_fill = PatternFill("solid", fgColor="2F5597")
    header_font = Font(name="Segoe UI", size=11, bold=True, color="FFFFFF")
    thin = Side(style="thin", color="D0D0D0")
    border_thin = Border(left=thin, right=thin, top=thin, bottom=thin)

    align_left = Alignment(horizontal="left", vertical="center")
    align_center = Alignment(horizontal="center", vertical="center")
    align_right = Alignment(horizontal="right", vertical="center")

    ws.row_dimensions[1].height = 28
    ws.row_dimensions[2].height = 28
    ws.row_dimensions[3].height = 16

    ws.merge_cells("A1:B3")

    if HAS_PIL and os.path.exists(LOGO_PATH):
        try:
            img = Image.open(LOGO_PATH)
            img.thumbnail((220, 70))
            tmp_path = os.path.join(REPORT_FOLDER, "_tmp_logo.png")
            img.save(tmp_path, format="PNG")
            from openpyxl.drawing.image import Image as XLImage
            xl_img = XLImage(tmp_path)
            xl_img.anchor = "A1"
            ws.add_image(xl_img)
        except Exception:
            pass

    ws.merge_cells("C1:I3")
    c = ws["C1"]
    c.value = "Daily Meter Reading Report"
    c.fill = title_fill
    c.font = title_font
    c.alignment = align_center

    for r in range(1, 4):
        for col in range(3, 10):
            ws.cell(row=r, column=col).fill = title_fill

    ws["A5"].value = "Date"
    ws["A5"].font = label_font
    ws["A5"].alignment = align_left
    ws["B5"].value = day_str
    ws["B5"].font = value_font
    ws["B5"].alignment = align_left

    ws["D5"].value = "Total Machines"
    ws["D5"].font = label_font
    ws["D5"].alignment = align_left
    ws["E5"].value = machine_count
    ws["E5"].font = value_font
    ws["E5"].alignment = align_left

    ws["A6"].value = "Readings Entered"
    ws["A6"].font = label_font
    ws["A6"].alignment = align_left
    ws["B6"].value = readings_entered
    ws["B6"].font = value_font
    ws["B6"].alignment = align_left

    ws["D6"].value = "Total Daily Consumption (kWh)"
    ws["D6"].font = label_font
    ws["D6"].alignment = align_left
    ws["E6"].value = round(total_use, DECIMALS)
    ws["E6"].font = value_font
    ws["E6"].alignment = align_left

    table_top = 10
    for i, h in enumerate(DAILY_HEADERS, start=1):
        cell = ws.cell(row=table_top, column=i, value=h)
        cell.fill = header_fill
        cell.font = header_font
        cell.alignment = align_center
        cell.border = border_thin

    start_row = table_top + 1
    zebra_fill = PatternFill("solid", fgColor="EEF3FB")

    for idx, row in df.reset_index(drop=True).iterrows():
        r = start_row + idx
        for cidx, col in enumerate(DAILY_HEADERS, start=1):
            val = row.get(col, "")
            cell = ws.cell(row=r, column=cidx, value=val)

            if col in ["PMNo", "MachineName", "Department", "Notes"]:
                cell.alignment = align_left
            else:
                cell.alignment = align_right

            cell.font = value_font
            cell.border = border_thin
            if idx % 2 == 1:
                cell.fill = zebra_fill

    last_row = table_top if len(df) == 0 else (start_row + len(df) - 1)
    ws.auto_filter.ref = f"A{table_top}:I{last_row}"
    ws.freeze_panes = f"A{start_row}"

    num_fmt = "0." + ("0" * DECIMALS)
    pct_fmt = f'0.{"0"*DECIMALS}"%"'
    if len(df) > 0:
        for r in range(start_row, last_row + 1):
            for col_letter in ["D", "E", "F", "G", "H"]:
                cell = ws[f"{col_letter}{r}"]
                cell.number_format = pct_fmt if col_letter == "H" else num_fmt

    footer_row = last_row + 2
    ws.merge_cells(f"B{footer_row}:I{footer_row}")
    fcell = ws[f"B{footer_row}"]
    fcell.value = f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M')} | System: Energy Monitoring System"
    fcell.font = Font(name="Segoe UI", size=9, color="666666")
    fcell.alignment = Alignment(horizontal="left", vertical="center")

    ws.page_setup.orientation = ws.ORIENTATION_LANDSCAPE
    ws.page_setup.fitToWidth = 1
    ws.page_setup.fitToHeight = 1

    fp = report_path(day_str)
    wb.save(fp)

    try:
        tmp_path = os.path.join(REPORT_FOLDER, "_tmp_logo.png")
        if os.path.exists(tmp_path):
            os.remove(tmp_path)
    except Exception:
        pass

    return fp


def write_only_meter_reading_report(day_str: str, df: pd.DataFrame):
    day_str = safe_date_str(day_str)
    wb = Workbook()
    ws = wb.active
    ws.title = "Only Meter Reading"

    col_widths = [14, 36, 18]
    for i, w in enumerate(col_widths, start=1):
        ws.column_dimensions[get_column_letter(i)].width = w

    title_fill = PatternFill("solid", fgColor="1F4E79")
    title_font = Font(name="Segoe UI", size=14, bold=True, color="FFFFFF")
    header_fill = PatternFill("solid", fgColor="2F5597")
    header_font = Font(name="Segoe UI", size=11, bold=True, color="FFFFFF")
    value_font = Font(name="Segoe UI", size=11)
    thin = Side(style="thin", color="D0D0D0")
    border_thin = Border(left=thin, right=thin, top=thin, bottom=thin)

    align_left = Alignment(horizontal="left", vertical="center")
    align_center = Alignment(horizontal="center", vertical="center")
    align_right = Alignment(horizontal="right", vertical="center")

    ws.merge_cells("A1:C2")
    c = ws["A1"]
    c.value = "Daily Meter Reading (Only)"
    c.fill = title_fill
    c.font = title_font
    c.alignment = align_center

    ws["A4"].value = "Date"
    ws["A4"].font = Font(name="Segoe UI", size=11, bold=True)
    ws["B4"].value = day_str
    ws["B4"].font = Font(name="Segoe UI", size=11)

    header_row = 6
    for i, h in enumerate(SIMPLE_HEADERS, start=1):
        cell = ws.cell(row=header_row, column=i, value=h)
        cell.fill = header_fill
        cell.font = header_font
        cell.alignment = align_center
        cell.border = border_thin

    start_row = header_row + 1
    zebra_fill = PatternFill("solid", fgColor="EEF3FB")

    simple_df = df[["PMNo", "MachineName", "Today_kWh"]].copy()
    for idx, row in simple_df.reset_index(drop=True).iterrows():
        r = start_row + idx
        for cidx, col in enumerate(SIMPLE_HEADERS, start=1):
            val = row.get(col, "")
            cell = ws.cell(row=r, column=cidx, value=val)
            cell.font = value_font
            cell.border = border_thin
            if col in ["PMNo", "MachineName"]:
                cell.alignment = align_left
            else:
                cell.alignment = align_right
            if idx % 2 == 1:
                cell.fill = zebra_fill

    last_row = header_row if len(simple_df) == 0 else (start_row + len(simple_df) - 1)
    ws.auto_filter.ref = f"A{header_row}:C{last_row}"
    ws.freeze_panes = f"A{start_row}"

    num_fmt = "0." + ("0" * DECIMALS)
    if len(simple_df) > 0:
        for r in range(start_row, last_row + 1):
            ws.cell(row=r, column=3).number_format = num_fmt

    footer_row = last_row + 2
    ws.merge_cells(f"B{footer_row}:C{footer_row}")
    fcell = ws[f"B{footer_row}"]
    fcell.value = f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M')} | System: Energy Monitoring System"
    fcell.font = Font(name="Segoe UI", size=9, color="666666")
    fcell.alignment = Alignment(horizontal="left", vertical="center")

    fp = simple_report_path(day_str)
    wb.save(fp)
    return fp


def write_electricians_report(day_str: str, df: pd.DataFrame):
    day_str = safe_date_str(day_str)
    wb = Workbook()
    ws = wb.active
    ws.title = "Electricians"

    col_widths = [14, 36, 18]
    for i, w in enumerate(col_widths, start=1):
        ws.column_dimensions[get_column_letter(i)].width = w

    title_fill = PatternFill("solid", fgColor="1F4E79")
    title_font = Font(name="Segoe UI", size=14, bold=True, color="FFFFFF")
    header_fill = PatternFill("solid", fgColor="2F5597")
    header_font = Font(name="Segoe UI", size=11, bold=True, color="FFFFFF")
    value_font = Font(name="Segoe UI", size=11)
    thin = Side(style="thin", color="D0D0D0")
    border_thin = Border(left=thin, right=thin, top=thin, bottom=thin)

    align_left = Alignment(horizontal="left", vertical="center")
    align_center = Alignment(horizontal="center", vertical="center")
    align_right = Alignment(horizontal="right", vertical="center")

    ws.merge_cells("A1:C2")
    c = ws["A1"]
    c.value = "Daily Electricians Meter Reading"
    c.fill = title_fill
    c.font = title_font
    c.alignment = align_center

    ws["A4"].value = "Date"
    ws["A4"].font = Font(name="Segoe UI", size=11, bold=True)
    ws["B4"].value = day_str
    ws["B4"].font = Font(name="Segoe UI", size=11)

    header_row = 6
    for i, h in enumerate(SIMPLE_HEADERS, start=1):
        cell = ws.cell(row=header_row, column=i, value=h)
        cell.fill = header_fill
        cell.font = header_font
        cell.alignment = align_center
        cell.border = border_thin

    start_row = header_row + 1
    zebra_fill = PatternFill("solid", fgColor="EEF3FB")

    for idx, row in df.reset_index(drop=True).iterrows():
        r = start_row + idx
        for cidx, col in enumerate(SIMPLE_HEADERS, start=1):
            val = row.get(col, "")
            cell = ws.cell(row=r, column=cidx, value=val)
            cell.font = value_font
            cell.border = border_thin
            if col in ["PMNo", "MachineName"]:
                cell.alignment = align_left
            else:
                cell.alignment = align_right
            if idx % 2 == 1:
                cell.fill = zebra_fill

    last_row = header_row if len(df) == 0 else (start_row + len(df) - 1)
    ws.auto_filter.ref = f"A{header_row}:C{last_row}"
    ws.freeze_panes = f"A{start_row}"

    num_fmt = "0." + ("0" * DECIMALS)
    if len(df) > 0:
        for r in range(start_row, last_row + 1):
            ws.cell(row=r, column=3).number_format = num_fmt

    footer_row = last_row + 2
    ws.merge_cells(f"B{footer_row}:C{footer_row}")
    fcell = ws[f"B{footer_row}"]
    fcell.value = f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M')} | System: Energy Monitoring System"
    fcell.font = Font(name="Segoe UI", size=9, color="666666")
    fcell.alignment = Alignment(horizontal="left", vertical="center")

    fp = electricians_report_path(day_str)
    wb.save(fp)
    return fp


def build_day_df(day_str: str):
    machines = load_machines_df()
    if machines.empty:
        raise ValueError("Machines list is empty. Add machines first.")

    prev_map, avg_map = compute_prev_and_avg_maps(day_str)
    existing = read_report_table(day_str)

    keep_today = {}
    keep_notes = {}
    if not existing.empty:
        keep_today = dict(zip(existing["PMNo"].astype(str), existing["Today_kWh"]))
        keep_notes = dict(zip(existing["PMNo"].astype(str), existing["Notes"]))

    df = machines.copy()
    df["Prev_kWh"] = df["PMNo"].map(prev_map)
    df["Today_kWh"] = df["PMNo"].map(keep_today)

    df["Daily_Use"] = pd.to_numeric(df["Today_kWh"], errors="coerce") - pd.to_numeric(df["Prev_kWh"], errors="coerce")
    df.loc[df["Daily_Use"] < 0, "Daily_Use"] = np.nan

    df["Avg_Daily"] = df["PMNo"].map(avg_map)
    df["%_vs_Avg"] = np.where(
        pd.to_numeric(df["Avg_Daily"], errors="coerce").notna()
        & (pd.to_numeric(df["Avg_Daily"], errors="coerce") != 0)
        & pd.to_numeric(df["Daily_Use"], errors="coerce").notna(),
        (pd.to_numeric(df["Daily_Use"], errors="coerce") - pd.to_numeric(df["Avg_Daily"], errors="coerce"))
        / pd.to_numeric(df["Avg_Daily"], errors="coerce") * 100.0,
        np.nan
    )
    df["Notes"] = df["PMNo"].map(keep_notes).fillna("")

    for c in ["Prev_kWh", "Today_kWh", "Daily_Use", "Avg_Daily", "%_vs_Avg"]:
        df[c] = pd.to_numeric(df[c], errors="coerce").round(DECIMALS)

    return df[DAILY_HEADERS].copy()


def upsert_reading(day_str: str, pmno: str, today_kwh: float, note: str):
    day_str = safe_date_str(day_str)
    pmno = (pmno or "").strip()

    df = build_day_df(day_str)
    if df.empty:
        raise ValueError("No machines found.")

    mask = df["PMNo"].astype(str).str.upper() == pmno.upper()
    if not mask.any():
        raise ValueError("PM No not found in Machines master.")

    df.loc[mask, "Today_kWh"] = float(today_kwh)
    df.loc[mask, "Notes"] = (note or "").strip()

    df["Daily_Use"] = pd.to_numeric(df["Today_kWh"], errors="coerce") - pd.to_numeric(df["Prev_kWh"], errors="coerce")
    df.loc[df["Daily_Use"] < 0, "Daily_Use"] = np.nan

    df["%_vs_Avg"] = np.where(
        pd.to_numeric(df["Avg_Daily"], errors="coerce").notna()
        & (pd.to_numeric(df["Avg_Daily"], errors="coerce") != 0)
        & pd.to_numeric(df["Daily_Use"], errors="coerce").notna(),
        (pd.to_numeric(df["Daily_Use"], errors="coerce") - pd.to_numeric(df["Avg_Daily"], errors="coerce"))
        / pd.to_numeric(df["Avg_Daily"], errors="coerce") * 100.0,
        np.nan
    )

    for c in ["Prev_kWh", "Today_kWh", "Daily_Use", "Avg_Daily", "%_vs_Avg"]:
        df[c] = pd.to_numeric(df[c], errors="coerce").round(DECIMALS)

    fp = write_professional_report(day_str, df)
    write_only_meter_reading_report(day_str, df)
    return fp


def build_electricians_df(day_str: str):
    machines = load_machines_df()
    if machines.empty:
        raise ValueError("Machines list is empty. Add machines first.")

    keep_today = {}
    existing = read_electricians_report(day_str)
    if not existing.empty:
        keep_today = dict(zip(existing["PMNo"].astype(str), existing["Today_kWh"]))

    df = machines[machines["PMNo"].isin(ELECTRICIANS_PMNOS)].copy()
    if df.empty:
        raise ValueError("Electricians PM Nos not found in Machines master.")

    df["Today_kWh"] = df["PMNo"].map(keep_today)
    df["Today_kWh"] = pd.to_numeric(df["Today_kWh"], errors="coerce").round(DECIMALS)
    return df[["PMNo", "MachineName", "Today_kWh"]].copy()


def upsert_electricians_reading(day_str: str, pmno: str, today_kwh: float):
    day_str = safe_date_str(day_str)
    pmno = (pmno or "").strip()

    df = build_electricians_df(day_str)
    mask = df["PMNo"].astype(str).str.upper() == pmno.upper()
    if not mask.any():
        raise ValueError("PM No not found in Electricians list.")

    df.loc[mask, "Today_kWh"] = float(today_kwh)
    df["Today_kWh"] = pd.to_numeric(df["Today_kWh"], errors="coerce").round(DECIMALS)
    write_electricians_report(day_str, df)
    return electricians_report_path(day_str)


# ---------------------------
# Monthly Report (FULL DAILY DATE DETAILS)
#   - Readings mode (existing): shows daily meter readings (cumulative)
#   - Daily Use mode (NEW): shows daily consumption per date (difference)
# ---------------------------

def build_monthly_detail_df(month_str: str, mode: str = "readings") -> pd.DataFrame:
    """
    Monthly report with ALL dates columns (YYYY-MM-DD):
    PMNo, MachineName, Department, 01..last day, Start_kWh, End_kWh, Monthly_Use, Days, Avg_Daily

    mode:
      - "readings": daily meter readings per date
      - "daily_use": daily consumption per date (diff from last available reading)
    """
    month_str = safe_month_str(month_str)
    machines = load_machines_df()
    if machines.empty:
        raise ValueError("Machines list is empty. Add machines first.")

    dates = month_date_list(month_str)
    date_cols = [d.strftime("%Y-%m-%d") for d in dates]

    hist = build_history_from_reports()
    df = machines.copy()

    # No history
    if hist.empty:
        for c in date_cols:
            df[c] = np.nan
        df["Start_kWh"] = np.nan
        df["End_kWh"] = np.nan
        df["Monthly_Use"] = np.nan
        df["Days"] = np.nan
        df["Avg_Daily"] = np.nan
        return df[["PMNo", "MachineName", "Department"] + date_cols + ["Start_kWh", "End_kWh", "Monthly_Use", "Days", "Avg_Daily"]]

    start_dt = pd.to_datetime(month_str + "-01")
    end_dt = start_dt + pd.offsets.MonthBegin(1)

    mdf = hist[(hist["Date"] >= start_dt) & (hist["Date"] < end_dt)].copy()
    if mdf.empty:
        for c in date_cols:
            df[c] = np.nan
        df["Start_kWh"] = np.nan
        df["End_kWh"] = np.nan
        df["Monthly_Use"] = np.nan
        df["Days"] = np.nan
        df["Avg_Daily"] = np.nan
        return df[["PMNo", "MachineName", "Department"] + date_cols + ["Start_kWh", "End_kWh", "Monthly_Use", "Days", "Avg_Daily"]]

    mdf["DateStr"] = mdf["Date"].dt.strftime("%Y-%m-%d")
    pv = mdf.pivot_table(index="PMNo", columns="DateStr", values="Today_kWh", aggfunc="last")

    # ensure all date columns exist
    for c in date_cols:
        if c not in pv.columns:
            pv[c] = np.nan
    pv = pv[date_cols].copy()

    pv = pv.reset_index()
    df = pd.merge(df, pv, on="PMNo", how="left")

    # Start/End = first/last non-null in month
    vals_only = df[date_cols].copy()
    start_kwh = vals_only.apply(lambda r: r.dropna().iloc[0] if r.dropna().shape[0] > 0 else np.nan, axis=1)
    end_kwh = vals_only.apply(lambda r: r.dropna().iloc[-1] if r.dropna().shape[0] > 0 else np.nan, axis=1)

    df["Start_kWh"] = pd.to_numeric(start_kwh, errors="coerce")
    df["End_kWh"] = pd.to_numeric(end_kwh, errors="coerce")

    df["Monthly_Use"] = df["End_kWh"] - df["Start_kWh"]
    df.loc[df["Monthly_Use"] < 0, "Monthly_Use"] = np.nan

    # Days = (last_read_date - first_read_date) in days, based on filled dates
    def calc_days(row):
        nonnull = [(i, row[dc]) for i, dc in enumerate(date_cols) if pd.notna(row[dc])]
        if len(nonnull) < 2:
            return np.nan
        first_idx = nonnull[0][0]
        last_idx = nonnull[-1][0]
        return float(last_idx - first_idx)

    df["Days"] = df.apply(calc_days, axis=1)
    df.loc[df["Days"] < 0, "Days"] = np.nan

    df["Avg_Daily"] = np.where(
        df["Days"].notna() & (df["Days"] > 0) & df["Monthly_Use"].notna(),
        df["Monthly_Use"] / df["Days"],
        np.nan
    )

    # NEW: daily_use mode
    if mode.strip().lower() == "daily_use":
        # last reading before month start (for first-day diff)
        before = (
            hist[hist["Date"] < start_dt]
            .sort_values(["PMNo", "Date"])
            .groupby("PMNo")
            .tail(1)[["PMNo", "Today_kWh"]]
            .rename(columns={"Today_kWh": "_PrevBefore"})
        )
        df = pd.merge(df, before, on="PMNo", how="left")

        prev_vals = pd.to_numeric(df["_PrevBefore"], errors="coerce")

        for dc in date_cols:
            cur = pd.to_numeric(df[dc], errors="coerce")

            use = cur - prev_vals
            use[(use < 0)] = np.nan
            use[cur.isna() | prev_vals.isna()] = np.nan

            df[dc] = use  # overwrite date column with daily use values

            # advance prev only when we have a new reading
            prev_vals = cur.where(cur.notna(), prev_vals)

        keep = ["PMNo", "MachineName", "Department"] + date_cols + ["Monthly_Use", "Days", "Avg_Daily"]
        for c in keep:
            if c not in df.columns:
                df[c] = np.nan

        for c in date_cols + ["Start_kWh", "End_kWh", "Monthly_Use", "Days", "Avg_Daily"]:
            df[c] = pd.to_numeric(df[c], errors="coerce").round(DECIMALS)

        return df[keep].copy()

    # readings mode
    for c in date_cols + ["Start_kWh", "End_kWh", "Monthly_Use", "Days", "Avg_Daily"]:
        df[c] = pd.to_numeric(df[c], errors="coerce").round(DECIMALS)

    return df[["PMNo", "MachineName", "Department"] + date_cols + ["Start_kWh", "End_kWh", "Monthly_Use", "Days", "Avg_Daily"]].copy()


def _write_month_sheet(ws, df: pd.DataFrame, month_str: str, title_text: str):
    title_fill = PatternFill("solid", fgColor="1F4E79")
    title_font = Font(name="Segoe UI", size=16, bold=True, color="FFFFFF")
    label_font = Font(name="Segoe UI", size=11, bold=True)
    value_font = Font(name="Segoe UI", size=11)
    header_fill = PatternFill("solid", fgColor="2F5597")
    header_font = Font(name="Segoe UI", size=10, bold=True, color="FFFFFF")
    thin = Side(style="thin", color="D0D0D0")
    border_thin = Border(left=thin, right=thin, top=thin, bottom=thin)

    align_left = Alignment(horizontal="left", vertical="center")
    align_center = Alignment(horizontal="center", vertical="center")
    align_right = Alignment(horizontal="right", vertical="center")

    headers = list(df.columns)

    # widths
    for i, h in enumerate(headers, start=1):
        col_letter = get_column_letter(i)
        if h in ("PMNo",):
            ws.column_dimensions[col_letter].width = 12
        elif h in ("MachineName",):
            ws.column_dimensions[col_letter].width = 28
        elif h in ("Department",):
            ws.column_dimensions[col_letter].width = 18
        elif re.match(r"^\d{4}-\d{2}-\d{2}$", str(h)):
            ws.column_dimensions[col_letter].width = 12
        else:
            ws.column_dimensions[col_letter].width = 14

    ws.row_dimensions[1].height = 28
    ws.row_dimensions[2].height = 28
    ws.row_dimensions[3].height = 16

    ws.merge_cells("A1:B3")

    if HAS_PIL and os.path.exists(LOGO_PATH):
        try:
            img = Image.open(LOGO_PATH)
            img.thumbnail((220, 70))
            tmp_path = os.path.join(MONTHLY_REPORT_FOLDER, "_tmp_logo.png")
            img.save(tmp_path, format="PNG")
            from openpyxl.drawing.image import Image as XLImage
            xl_img = XLImage(tmp_path)
            xl_img.anchor = "A1"
            ws.add_image(xl_img)
        except Exception:
            pass

    # Title across all columns
    ws.merge_cells(start_row=1, start_column=3, end_row=3, end_column=len(headers))
    c = ws.cell(row=1, column=3)
    c.value = title_text
    c.fill = title_fill
    c.font = title_font
    c.alignment = align_center
    for r in range(1, 4):
        for col in range(3, len(headers) + 1):
            ws.cell(row=r, column=col).fill = title_fill

    # Summary
    ws["A5"].value = "Month"
    ws["A5"].font = label_font
    ws["A5"].alignment = align_left
    ws["B5"].value = month_str
    ws["B5"].font = value_font
    ws["B5"].alignment = align_left

    ws["D5"].value = "Total Machines"
    ws["D5"].font = label_font
    ws["D5"].alignment = align_left
    ws["E5"].value = int(len(df))
    ws["E5"].font = value_font
    ws["E5"].alignment = align_left

    total_monthly = float(pd.to_numeric(df.get("Monthly_Use", 0), errors="coerce").fillna(0).sum()) if len(df) else 0.0

    ws["A6"].value = "Total Monthly Consumption (kWh)"
    ws["A6"].font = label_font
    ws["A6"].alignment = align_left
    ws["B6"].value = round(total_monthly, DECIMALS)
    ws["B6"].font = value_font
    ws["B6"].alignment = align_left

    # Table header row
    table_top = 10
    for i, h in enumerate(headers, start=1):
        cell = ws.cell(row=table_top, column=i, value=h)
        cell.fill = header_fill
        cell.font = header_font
        cell.alignment = align_center
        cell.border = border_thin

    start_row = table_top + 1
    zebra_fill = PatternFill("solid", fgColor="EEF3FB")

    # Data
    for ridx, row in enumerate(df.itertuples(index=False), start=0):
        r = start_row + ridx
        for cidx, h in enumerate(headers, start=1):
            val = getattr(row, h) if hasattr(row, h) else None
            cell = ws.cell(row=r, column=cidx, value=val)

            if h in ("PMNo", "MachineName", "Department"):
                cell.alignment = align_left
            else:
                cell.alignment = align_right

            cell.font = value_font
            cell.border = border_thin
            if ridx % 2 == 1:
                cell.fill = zebra_fill

    last_row = table_top if len(df) == 0 else (start_row + len(df) - 1)
    ws.auto_filter.ref = f"A{table_top}:{get_column_letter(len(headers))}{last_row}"
    ws.freeze_panes = f"A{start_row}"

    num_fmt = "0." + ("0" * DECIMALS)
    if len(df) > 0:
        for r in range(start_row, last_row + 1):
            for cidx, h in enumerate(headers, start=1):
                if h in ("PMNo", "MachineName", "Department"):
                    continue
                ws.cell(row=r, column=cidx).number_format = num_fmt

    footer_row = last_row + 2
    ws.merge_cells(start_row=footer_row, start_column=2, end_row=footer_row, end_column=len(headers))
    fcell = ws.cell(row=footer_row, column=2)
    fcell.value = f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M')} | System: Energy Monitoring System"
    fcell.font = Font(name="Segoe UI", size=9, color="666666")
    fcell.alignment = Alignment(horizontal="left", vertical="center")

    ws.page_setup.orientation = ws.ORIENTATION_LANDSCAPE
    ws.page_setup.fitToWidth = 1
    ws.page_setup.fitToHeight = 0


def write_monthly_report(month_str: str, df_readings: pd.DataFrame, df_daily_use: pd.DataFrame):
    """
    Writes monthly report with TWO sheets:
      - Readings (daily meter readings)
      - Daily_Use (daily consumption)
    """
    month_str = safe_month_str(month_str)

    wb = Workbook()

    ws1 = wb.active
    ws1.title = "Readings"
    _write_month_sheet(ws1, df_readings, month_str, "Monthly Meter Reading Report (Daily Readings)")

    ws2 = wb.create_sheet("Daily_Use")
    _write_month_sheet(ws2, df_daily_use, month_str, "Monthly Meter Reading Report (Daily Use)")

    fp = monthly_report_path(month_str)
    wb.save(fp)

    try:
        tmp_path = os.path.join(MONTHLY_REPORT_FOLDER, "_tmp_logo.png")
        if os.path.exists(tmp_path):
            os.remove(tmp_path)
    except Exception:
        pass

    return fp


# ---------------------------
# UI App
# ---------------------------
class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Machine kWh Monitoring System")
        self.geometry("1100x650")
        self.minsize(950, 580)

        style = ttk.Style(self)
        try:
            style.theme_use("clam")
        except Exception:
            pass

        style.configure("TFrame", background="#F5F7FA")
        style.configure("TLabel", background="#F5F7FA", font=("Segoe UI", 10))
        style.configure("TButton", font=("Segoe UI", 10), padding=8)
        style.configure("TEntry", padding=6)
        style.configure("Header.TLabel", font=("Segoe UI", 13, "bold"), background="#F5F7FA")
        style.configure("SubHeader.TLabel", font=("Segoe UI", 10, "bold"), background="#F5F7FA")
        style.configure("Title.TLabel", font=("Segoe UI", 12, "bold"), background="#F5F7FA")
        style.configure("Treeview", font=("Segoe UI", 10), rowheight=26)
        style.configure("Treeview.Heading", font=("Segoe UI", 10, "bold"))

        self.pm_var = tk.StringVar()
        self.name_var = tk.StringVar()
        self.department_var = tk.StringVar(value=DEPARTMENTS[0])

        self.day_var = tk.StringVar(value=datetime.now().strftime("%Y-%m-%d"))
        self.machine_search_var = tk.StringVar()
        self.today_var = tk.StringVar()
        self.notes_var = tk.StringVar()

        self.view_date_var = tk.StringVar(value=datetime.now().strftime("%Y-%m-%d"))
        self.view_department_var = tk.StringVar(value="All")
        self.month_var = tk.StringVar(value=datetime.now().strftime("%Y-%m"))
        self.month_department_var = tk.StringVar(value="All")

        # NEW: monthly view mode (Readings / Daily Use)
        self.month_view_var = tk.StringVar(value="Readings")

        self.elec_day_var = tk.StringVar(value=datetime.now().strftime("%Y-%m-%d"))
        self.elec_machine_var = tk.StringVar()
        self.elec_today_var = tk.StringVar()

        self.status_var = tk.StringVar(value="Ready")

        ensure_machines_file()

        self.nb = ttk.Notebook(self)
        self.nb.pack(fill="both", expand=True, padx=12, pady=(12, 0))

        self.tab_machines = ttk.Frame(self.nb)
        self.tab_daily = ttk.Frame(self.nb)
        self.tab_view = ttk.Frame(self.nb)
        self.tab_monthly = ttk.Frame(self.nb)
        self.tab_electricians = ttk.Frame(self.nb)

        self.nb.add(self.tab_machines, text="Add Machines")
        self.nb.add(self.tab_daily, text="Daily Entry")
        self.nb.add(self.tab_electricians, text="Electricians Entry")
        self.nb.add(self.tab_view, text="View Day Sheet")
        self.nb.add(self.tab_monthly, text="Monthly Report")

        self.build_machines_tab()
        self.build_daily_tab()
        self.build_view_tab()
        self.build_monthly_tab()
        self.build_electricians_tab()

        self.status_bar = tk.Label(
            self,
            textvariable=self.status_var,
            anchor="w",
            font=("Segoe UI", 9),
            fg="#2E7D32",
            bg="#F1F3F6",
            padx=10,
            pady=6
        )
        self.status_bar.pack(fill="x", side="bottom")

        self.refresh_machine_list()
        self.refresh_machine_suggestions()
        self.refresh_view_dates()
        self.load_day_table()

        self.refresh_month_options()
        self.load_month_view()
        self.refresh_electricians_suggestions()
        self.load_electricians_table()

    def fmt4(self, v):
        try:
            if v is None:
                return ""
            if isinstance(v, float) and np.isnan(v):
                return ""
            return f"{float(v):.{DECIMALS}f}"
        except Exception:
            return ""

    def set_status(self, text: str, ok: bool = True):
        self.status_var.set(text)
        self.status_bar.config(fg=("#2E7D32" if ok else "#C62828"))

    # ---------------- Machines Tab ----------------
    def build_machines_tab(self):
        root = self.tab_machines
        root.columnconfigure(0, weight=1)
        root.rowconfigure(2, weight=1)

        header = ttk.Label(root, text="Machine Master", style="Header.TLabel")
        header.grid(row=0, column=0, sticky="w", padx=18, pady=(18, 10))

        card = ttk.Frame(root, padding=16)
        card.grid(row=1, column=0, sticky="ew", padx=18, pady=(0, 12))
        card.columnconfigure(1, weight=1)

        ttk.Label(card, text="PM No", style="SubHeader.TLabel").grid(row=0, column=0, sticky="w", pady=(0, 6))
        ttk.Entry(card, textvariable=self.pm_var, width=25).grid(row=0, column=1, sticky="w", pady=(0, 6))

        ttk.Label(card, text="Machine Name", style="SubHeader.TLabel").grid(row=1, column=0, sticky="w", pady=(0, 6))
        ttk.Entry(card, textvariable=self.name_var, width=50).grid(row=1, column=1, sticky="ew", pady=(0, 6))

        ttk.Label(card, text="Department", style="SubHeader.TLabel").grid(row=2, column=0, sticky="w", pady=(0, 10))
        self.department_combo = ttk.Combobox(
            card,
            textvariable=self.department_var,
            values=DEPARTMENTS,
            state="readonly",
            width=24
        )
        self.department_combo.grid(row=2, column=1, sticky="w", pady=(0, 10))

        btns = ttk.Frame(card)
        btns.grid(row=3, column=1, sticky="e")
        ttk.Button(btns, text="Add Machine", command=self.on_add_machine).pack(side="left")

        list_card = ttk.Frame(root, padding=20)
        list_card.grid(row=2, column=0, sticky="nsew", padx=18, pady=(0, 18))
        list_card.rowconfigure(1, weight=1)
        list_card.columnconfigure(0, weight=1)

        ttk.Label(list_card, text="Machines List", style="Title.TLabel").grid(row=0, column=0, sticky="w", pady=(0, 10))

        cols = ("PMNo", "MachineName", "Department", "Action")
        self.machine_tree = ttk.Treeview(list_card, columns=cols, show="headings", height=12)
        self.machine_tree.heading("PMNo", text="PM No")
        self.machine_tree.heading("MachineName", text="Machine Name")
        self.machine_tree.heading("Department", text="Department")
        self.machine_tree.heading("Action", text="Action")

        self.machine_tree.column("PMNo", width=120, anchor="w", stretch=False)
        self.machine_tree.column("MachineName", width=420, anchor="w", stretch=True)
        self.machine_tree.column("Department", width=160, anchor="w", stretch=False)
        self.machine_tree.column("Action", width=120, anchor="center", stretch=False)

        self.machine_tree.grid(row=1, column=0, sticky="nsew")

        scroll = ttk.Scrollbar(list_card, orient="vertical", command=self.machine_tree.yview)
        self.machine_tree.configure(yscrollcommand=scroll.set)
        scroll.grid(row=1, column=1, sticky="ns")

        self.machine_tree.bind("<Button-1>", self.on_machine_tree_click)

    def on_add_machine(self):
        try:
            add_machine(self.pm_var.get(), self.name_var.get(), self.department_var.get())
            self.pm_var.set("")
            self.name_var.set("")
            self.department_var.set(DEPARTMENTS[0])
            self.refresh_machine_list()
            self.refresh_machine_suggestions()
            self.set_status("Saved ✓ | Machine added", ok=True)
        except Exception as e:
            self.set_status(f"Error: {e}", ok=False)
            messagebox.showerror("Error", str(e))

    def on_machine_tree_click(self, event):
        region = self.machine_tree.identify("region", event.x, event.y)
        if region != "cell":
            return

        col = self.machine_tree.identify_column(event.x)
        row_id = self.machine_tree.identify_row(event.y)
        if not row_id:
            return

        values = self.machine_tree.item(row_id, "values")
        if not values:
            return

        pmno = values[0]
        mname = values[1]

        if col == "#4":
            if not messagebox.askyesno("Confirm Delete", f"Delete this machine?\n\n{pmno} - {mname}"):
                return
            try:
                delete_machine(pmno)
                self.refresh_machine_list()
                self.refresh_machine_suggestions()
                self.set_status(f"Deleted ✓ | {pmno}", ok=True)
            except Exception as e:
                self.set_status(f"Error: {e}", ok=False)
                messagebox.showerror("Error", str(e))

    def refresh_machine_list(self):
        for item in self.machine_tree.get_children():
            self.machine_tree.delete(item)
        df = load_machines_df()
        for _, r in df.iterrows():
            self.machine_tree.insert(
                "",
                tk.END,
                values=(r["PMNo"], r["MachineName"], r["Department"], "Delete")
            )

    # ---------------- Daily Entry Tab ----------------
    def clear_day_table(self):
        for item in self.day_tree.get_children():
            self.day_tree.delete(item)

    def load_day_table(self):
        day = (self.day_var.get() or "").strip()
        if not day:
            return
        try:
            df = build_day_df(day)
        except Exception:
            self.clear_day_table()
            return

        self.clear_day_table()
        show_df = df[["PMNo", "MachineName", "Department", "Prev_kWh", "Today_kWh", "Daily_Use"]].copy()
        show_df = show_df.replace({np.nan: ""})

        for _, r in show_df.iterrows():
            today = r["Today_kWh"]
            tags = ()
            if today == "" or pd.isna(today):
                tags = ("missing_today",)

            self.day_tree.insert(
                "",
                tk.END,
                values=(
                    r["PMNo"],
                    r["MachineName"],
                    r["Department"],
                    self.fmt4(r["Prev_kWh"]),
                    self.fmt4(r["Today_kWh"]),
                    self.fmt4(r["Daily_Use"])
                ),
                tags=tags
            )

    def on_day_row_select(self, event=None):
        sel = self.day_tree.selection()
        if not sel:
            return
        vals = self.day_tree.item(sel[0], "values")
        if not vals:
            return
        pmno = str(vals[0]).strip()
        mname = str(vals[1]).strip()
        self.machine_search_var.set(f"{pmno} - {mname}")
        self.today_entry.focus_set()
        self.today_entry.selection_range(0, tk.END)

    def build_daily_tab(self):
        root = self.tab_daily
        root.columnconfigure(0, weight=1)
        root.rowconfigure(2, weight=1)

        header = ttk.Label(root, text="Daily Entry", style="Header.TLabel")
        header.grid(row=0, column=0, sticky="w", padx=18, pady=(18, 10))

        card = ttk.Frame(root, padding=16)
        card.grid(row=1, column=0, sticky="ew", padx=18, pady=(0, 12))
        card.columnconfigure(3, weight=1)

        ttk.Label(card, text="Date", style="SubHeader.TLabel").grid(row=0, column=0, sticky="w", pady=(0, 10))
        if HAS_TKCAL:
            self.day_cal = DateEntry(card, width=16, date_pattern="yyyy-mm-dd", textvariable=self.day_var)
            self.day_cal.grid(row=0, column=1, sticky="w", pady=(0, 10))
            self.day_cal.bind("<<DateEntrySelected>>", lambda e: self.load_day_table())
        else:
            ttk.Entry(card, textvariable=self.day_var, width=18).grid(row=0, column=1, sticky="w", pady=(0, 10))

        ttk.Separator(card).grid(row=1, column=0, columnspan=4, sticky="ew", pady=10)

        ttk.Label(card, text="Select Machine (Type PM No or Name)", style="SubHeader.TLabel").grid(row=2, column=0, sticky="w", pady=(0, 6))

        self.machine_combo = ttk.Combobox(card, textvariable=self.machine_search_var, width=55)
        self.machine_combo.grid(row=2, column=1, columnspan=3, sticky="ew", pady=(0, 6))
        self.machine_combo.bind("<KeyRelease>", self.on_machine_type)
        self.machine_combo.bind("<<ComboboxSelected>>", self.on_machine_selected)
        self.machine_combo.bind("<Return>", self.on_machine_enter)

        ttk.Label(card, text="Today kWh Reading", style="SubHeader.TLabel").grid(row=3, column=0, sticky="w", pady=(12, 6))
        self.today_entry = ttk.Entry(card, textvariable=self.today_var, width=20)
        self.today_entry.grid(row=3, column=1, sticky="w", pady=(12, 6))
        self.today_entry.bind("<Return>", self.on_today_enter)

        ttk.Label(card, text="Notes (optional)", style="SubHeader.TLabel").grid(row=4, column=0, sticky="w", pady=(12, 6))
        self.notes_entry = ttk.Entry(card, textvariable=self.notes_var)
        self.notes_entry.grid(row=4, column=1, columnspan=3, sticky="ew", pady=(12, 6))
        self.notes_entry.bind("<Return>", self.on_notes_enter)

        btn_row = ttk.Frame(card)
        btn_row.grid(row=5, column=0, columnspan=4, sticky="e", pady=(16, 0))
        ttk.Button(btn_row, text="Save Reading", command=self.on_save_reading).pack(side="left")

        table_frame = ttk.Frame(root, padding=(18, 0))
        table_frame.grid(row=2, column=0, sticky="nsew", padx=18, pady=(0, 18))
        table_frame.rowconfigure(1, weight=1)
        table_frame.columnconfigure(0, weight=1)

        ttk.Label(table_frame, text="Day Data", style="Title.TLabel").grid(row=0, column=0, sticky="w", pady=(8, 8))

        day_cols = ("PMNo", "MachineName", "Department", "Prev_kWh", "Today_kWh", "Daily_Use")
        self.day_tree = ttk.Treeview(table_frame, columns=day_cols, show="headings", height=14)
        self.day_tree.heading("PMNo", text="PM No")
        self.day_tree.heading("MachineName", text="Machine Name")
        self.day_tree.heading("Department", text="Department")
        self.day_tree.heading("Prev_kWh", text="Prev Reading")
        self.day_tree.heading("Today_kWh", text="Today Reading")
        self.day_tree.heading("Daily_Use", text="Daily Use")

        self.day_tree.column("PMNo", width=120, anchor="w", stretch=False)
        self.day_tree.column("MachineName", width=320, anchor="w", stretch=True)
        self.day_tree.column("Department", width=160, anchor="w", stretch=False)
        self.day_tree.column("Prev_kWh", width=140, anchor="center", stretch=False)
        self.day_tree.column("Today_kWh", width=140, anchor="center", stretch=False)
        self.day_tree.column("Daily_Use", width=140, anchor="center", stretch=False)

        self.day_tree.grid(row=1, column=0, sticky="nsew")

        day_scroll = ttk.Scrollbar(table_frame, orient="vertical", command=self.day_tree.yview)
        self.day_tree.configure(yscrollcommand=day_scroll.set)
        day_scroll.grid(row=1, column=1, sticky="ns")

        self.day_tree.tag_configure("missing_today", background="#FFE5E5")
        self.day_tree.bind("<<TreeviewSelect>>", self.on_day_row_select)
        self.day_tree.bind("<Double-1>", self.on_day_row_select)

    # ---------------- Electricians Entry Tab ----------------
    def build_electricians_tab(self):
        root = self.tab_electricians
        root.columnconfigure(0, weight=1)
        root.rowconfigure(2, weight=1)

        header = ttk.Label(root, text="Electricians Entry", style="Header.TLabel")
        header.grid(row=0, column=0, sticky="w", padx=18, pady=(18, 10))

        card = ttk.Frame(root, padding=16)
        card.grid(row=1, column=0, sticky="ew", padx=18, pady=(0, 12))
        card.columnconfigure(3, weight=1)

        ttk.Label(card, text="Date", style="SubHeader.TLabel").grid(row=0, column=0, sticky="w", pady=(0, 10))
        if HAS_TKCAL:
            self.elec_day_cal = DateEntry(card, width=16, date_pattern="yyyy-mm-dd", textvariable=self.elec_day_var)
            self.elec_day_cal.grid(row=0, column=1, sticky="w", pady=(0, 10))
            self.elec_day_cal.bind("<<DateEntrySelected>>", lambda e: self.load_electricians_table())
        else:
            ttk.Entry(card, textvariable=self.elec_day_var, width=18).grid(row=0, column=1, sticky="w", pady=(0, 10))

        ttk.Separator(card).grid(row=1, column=0, columnspan=4, sticky="ew", pady=10)

        ttk.Label(card, text="Select Meter (PM 01, PM 32, PM 19)", style="SubHeader.TLabel").grid(row=2, column=0, sticky="w", pady=(0, 6))
        self.elec_machine_combo = ttk.Combobox(card, textvariable=self.elec_machine_var, width=40, state="readonly")
        self.elec_machine_combo.grid(row=2, column=1, columnspan=2, sticky="w", pady=(0, 6))
        self.elec_machine_combo.bind("<<ComboboxSelected>>", lambda e: self.elec_today_entry.focus_set())

        ttk.Label(card, text="Today kWh Reading", style="SubHeader.TLabel").grid(row=3, column=0, sticky="w", pady=(12, 6))
        self.elec_today_entry = ttk.Entry(card, textvariable=self.elec_today_var, width=20)
        self.elec_today_entry.grid(row=3, column=1, sticky="w", pady=(12, 6))
        self.elec_today_entry.bind("<Return>", lambda e: self.on_save_electricians())

        btn_row = ttk.Frame(card)
        btn_row.grid(row=4, column=0, columnspan=4, sticky="e", pady=(16, 0))
        ttk.Button(btn_row, text="Save Electricians Reading", command=self.on_save_electricians).pack(side="left")

        table_frame = ttk.Frame(root, padding=(18, 0))
        table_frame.grid(row=2, column=0, sticky="nsew", padx=18, pady=(0, 18))
        table_frame.rowconfigure(1, weight=1)
        table_frame.columnconfigure(0, weight=1)

        ttk.Label(table_frame, text="Electricians Data", style="Title.TLabel").grid(row=0, column=0, sticky="w", pady=(8, 8))

        elec_cols = ("PMNo", "MachineName", "Today_kWh")
        self.elec_tree = ttk.Treeview(table_frame, columns=elec_cols, show="headings", height=10)
        self.elec_tree.heading("PMNo", text="PM No")
        self.elec_tree.heading("MachineName", text="Machine Name")
        self.elec_tree.heading("Today_kWh", text="Today Reading")
        self.elec_tree.column("PMNo", width=120, anchor="w", stretch=False)
        self.elec_tree.column("MachineName", width=360, anchor="w", stretch=True)
        self.elec_tree.column("Today_kWh", width=140, anchor="center", stretch=False)
        self.elec_tree.grid(row=1, column=0, sticky="nsew")

        elec_scroll = ttk.Scrollbar(table_frame, orient="vertical", command=self.elec_tree.yview)
        self.elec_tree.configure(yscrollcommand=elec_scroll.set)
        elec_scroll.grid(row=1, column=1, sticky="ns")

    def load_electricians_table(self):
        day = (self.elec_day_var.get() or "").strip()
        if not day:
            return
        try:
            df = build_electricians_df(day)
        except Exception:
            self.clear_electricians_table()
            return

        self.clear_electricians_table()
        show_df = df.replace({np.nan: ""})
        for _, r in show_df.iterrows():
            self.elec_tree.insert(
                "",
                tk.END,
                values=(r["PMNo"], r["MachineName"], self.fmt4(r["Today_kWh"]))
            )

    def clear_electricians_table(self):
        for item in self.elec_tree.get_children():
            self.elec_tree.delete(item)

    def _current_electricians_pmno(self) -> str:
        sel = (self.elec_machine_var.get() or "").strip()
        if " - " in sel:
            return sel.split(" - ", 1)[0].strip()
        return sel.strip()

    def on_save_electricians(self):
        try:
            day = safe_date_str(self.elec_day_var.get())
            pmno = self._current_electricians_pmno()
            if not pmno:
                raise ValueError("Select a PM No.")

            today_txt = self.elec_today_var.get().strip()
            if not today_txt:
                raise ValueError("Enter Today kWh reading.")
            today_val = float(today_txt)

            upsert_electricians_reading(day, pmno, today_val)
            self.set_status(f"Saved ✓ | Electricians | {pmno} | {today_val:.4f} kWh | {day}", ok=True)
            self.elec_today_var.set("")
            self.load_electricians_table()
        except Exception as e:
            self.set_status(f"Error: {e}", ok=False)
            messagebox.showerror("Error", str(e))

    def refresh_machine_suggestions(self):
        df = load_machines_df()
        self._all_machine_items = [f"{r['PMNo']} - {r['MachineName']}" for _, r in df.iterrows()]
        self.machine_combo["values"] = self._all_machine_items
        if self._all_machine_items and not self.machine_search_var.get().strip():
            self.machine_search_var.set(self._all_machine_items[0])

    def refresh_electricians_suggestions(self):
        df = load_machines_df()
        df = df[df["PMNo"].isin(ELECTRICIANS_PMNOS)]
        self._elec_machine_items = [f"{r['PMNo']} - {r['MachineName']}" for _, r in df.iterrows()]
        self.elec_machine_combo["values"] = self._elec_machine_items
        if self._elec_machine_items and not self.elec_machine_var.get().strip():
            self.elec_machine_var.set(self._elec_machine_items[0])

    def on_machine_type(self, event=None):
        text = self.machine_search_var.get().strip().lower()
        if not hasattr(self, "_all_machine_items"):
            self.refresh_machine_suggestions()
        if not text:
            self.machine_combo["values"] = self._all_machine_items
            return
        filtered = [x for x in self._all_machine_items if text in x.lower()]
        self.machine_combo["values"] = filtered if filtered else self._all_machine_items

    def on_machine_selected(self, event=None):
        self.today_entry.focus_set()
        self.today_entry.selection_range(0, tk.END)

    def on_machine_enter(self, event=None):
        vals = list(self.machine_combo["values"])
        if vals:
            self.machine_search_var.set(vals[0])
        self.today_entry.focus_set()
        self.today_entry.selection_range(0, tk.END)

    def on_today_enter(self, event=None):
        self.notes_entry.focus_set()
        self.notes_entry.selection_range(0, tk.END)

    def on_notes_enter(self, event=None):
        self.on_save_reading()

    def _current_pmno(self) -> str:
        sel = (self.machine_search_var.get() or "").strip()
        if " - " in sel:
            return sel.split(" - ", 1)[0].strip()
        return sel.strip()

    def on_save_reading(self):
        try:
            day = safe_date_str(self.day_var.get())
            pmno = self._current_pmno()
            if not pmno:
                raise ValueError("Select a machine (PM No).")

            today_txt = self.today_var.get().strip()
            if not today_txt:
                raise ValueError("Enter Today kWh reading.")
            today_val = float(today_txt)

            note = self.notes_var.get().strip()

            upsert_reading(day, pmno, today_val, note)

            self.set_status(f"Saved ✓ | {pmno} | {today_val:.4f} kWh | {day}", ok=True)

            self.today_var.set("")
            self.notes_var.set("")

            self.move_to_next_machine()
            self.today_entry.focus_set()

            self.refresh_view_dates()
            self.load_day_table()
            self.refresh_month_options()
            self.load_month_view()

        except Exception as e:
            self.set_status(f"Error: {e}", ok=False)
            messagebox.showerror("Error", str(e))

    def move_to_next_machine(self):
        if not hasattr(self, "_all_machine_items"):
            self.refresh_machine_suggestions()

        current = (self.machine_search_var.get() or "").strip()
        items = self._all_machine_items[:] if hasattr(self, "_all_machine_items") else []
        if not items:
            return

        if current not in items:
            pm = self._current_pmno().upper()
            for it in items:
                if it.split(" - ", 1)[0].strip().upper() == pm:
                    current = it
                    break

        try:
            idx = items.index(current)
            next_idx = (idx + 1) % len(items)
            self.machine_search_var.set(items[next_idx])
        except Exception:
            self.machine_search_var.set(items[0])

    # ---------------- View Day Sheet Tab ----------------
    def build_view_tab(self):
        root = self.tab_view
        root.columnconfigure(0, weight=1)
        root.rowconfigure(2, weight=1)

        header = ttk.Label(root, text="View Day Report", style="Header.TLabel")
        header.grid(row=0, column=0, sticky="w", padx=18, pady=(18, 10))

        top = ttk.Frame(root, padding=(16, 10))
        top.grid(row=1, column=0, sticky="ew", padx=18)

        ttk.Label(top, text="Select Date", style="SubHeader.TLabel").grid(row=0, column=0, sticky="w")

        if HAS_TKCAL:
            self.view_date_cal = DateEntry(top, width=16, date_pattern="yyyy-mm-dd", textvariable=self.view_date_var)
            self.view_date_cal.grid(row=0, column=1, sticky="w", padx=(10, 8))
            self.view_date_cal.bind("<<DateEntrySelected>>", lambda e: self.load_view_date())
        else:
            self.view_date_entry = ttk.Entry(top, textvariable=self.view_date_var, width=18)
            self.view_date_entry.grid(row=0, column=1, sticky="w", padx=(10, 8))
            self.view_date_entry.bind("<Return>", lambda e: self.load_view_date())
            self.view_date_entry.bind("<FocusOut>", lambda e: self.load_view_date())

        ttk.Label(top, text="Department", style="SubHeader.TLabel").grid(row=0, column=3, sticky="w", padx=(20, 0))
        self.view_department_combo = ttk.Combobox(
            top,
            textvariable=self.view_department_var,
            values=VIEW_DEPARTMENTS,
            state="readonly",
            width=16
        )
        self.view_department_combo.grid(row=0, column=4, sticky="w", padx=(8, 0))
        self.view_department_combo.bind("<<ComboboxSelected>>", lambda e: self.load_view_date())

        table_frame = ttk.Frame(root, padding=(16, 10))
        table_frame.grid(row=2, column=0, sticky="nsew", padx=18, pady=(0, 12))
        table_frame.rowconfigure(0, weight=1)
        table_frame.columnconfigure(0, weight=1)

        self.view_tree = ttk.Treeview(table_frame, columns=DAILY_HEADERS, show="headings")
        for c in DAILY_HEADERS:
            self.view_tree.heading(c, text=c)
            if c == "MachineName":
                self.view_tree.column(c, width=200, anchor="w")
            elif c == "Department":
                self.view_tree.column(c, width=150, anchor="w")
            elif c == "Notes":
                self.view_tree.column(c, width=220, anchor="w")
            else:
                self.view_tree.column(c, width=120, anchor="center")
        self.view_tree.grid(row=0, column=0, sticky="nsew")

        vs = ttk.Scrollbar(table_frame, orient="vertical", command=self.view_tree.yview)
        self.view_tree.configure(yscrollcommand=vs.set)
        vs.grid(row=0, column=1, sticky="ns")

    def refresh_view_dates(self):
        dates = list_report_dates()
        if dates:
            self.view_date_var.set(dates[-1])
            self.load_view_date()
        else:
            self.clear_view_table()
            self.set_status("No reports found yet.", ok=False)

    def clear_view_table(self):
        for item in self.view_tree.get_children():
            self.view_tree.delete(item)

    def load_view_date(self):
        day = (self.view_date_var.get() or "").strip()
        if not day:
            return

        fp = report_path(day)
        if not os.path.exists(fp):
            self.clear_view_table()
            self.set_status(f"No data for this date: {day}", ok=False)
            return

        df = read_report_table(day)
        department = (self.view_department_var.get() or "All").strip()
        if department and department != "All":
            df = df[df["Department"] == department]

        self.clear_view_table()
        if df.empty:
            self.set_status(f"No data rows for {department or 'All'} on {day}.", ok=False)
            return

        num_cols = {"Prev_kWh", "Today_kWh", "Daily_Use", "Avg_Daily", "%_vs_Avg"}
        for _, r in df.iterrows():
            row_vals = []
            for c in DAILY_HEADERS:
                v = r.get(c, "")
                if c in num_cols:
                    row_vals.append(self.fmt4(v))
                else:
                    row_vals.append(v if v is not None else "")
            self.view_tree.insert("", tk.END, values=row_vals)

        filter_label = department if department else "All"
        self.set_status(f"Loaded ✓ | {day} | Department: {filter_label} | Machines: {len(df)}", ok=True)

    # ---------------- Monthly Tab ----------------
    def build_monthly_tab(self):
        root = self.tab_monthly
        root.columnconfigure(0, weight=1)
        root.rowconfigure(2, weight=1)

        header = ttk.Label(root, text="Monthly Report (Daily Details)", style="Header.TLabel")
        header.grid(row=0, column=0, sticky="w", padx=18, pady=(18, 10))

        top = ttk.Frame(root, padding=(16, 10))
        top.grid(row=1, column=0, sticky="ew", padx=18)

        ttk.Label(top, text="Select Month (YYYY-MM)", style="SubHeader.TLabel").grid(row=0, column=0, sticky="w")

        self.month_combo = ttk.Combobox(top, textvariable=self.month_var, width=14)
        self.month_combo.grid(row=0, column=1, sticky="w", padx=(10, 8))
        self.month_combo.bind("<<ComboboxSelected>>", lambda e: self.load_month_view())
        self.month_combo.bind("<Return>", lambda e: self.load_month_view())
        self.month_combo.bind("<FocusOut>", lambda e: self.load_month_view())

        # NEW: View mode dropdown
        ttk.Label(top, text="View", style="SubHeader.TLabel").grid(row=0, column=4, sticky="w", padx=(20, 0))
        self.month_view_combo = ttk.Combobox(
            top,
            textvariable=self.month_view_var,
            width=12,
            state="readonly",
            values=["Readings", "Daily Use"]
        )
        self.month_view_combo.grid(row=0, column=5, sticky="w", padx=(8, 0))
        self.month_view_combo.bind("<<ComboboxSelected>>", lambda e: self.load_month_view())

        ttk.Label(top, text="Department", style="SubHeader.TLabel").grid(row=0, column=6, sticky="w", padx=(20, 0))
        self.month_department_combo = ttk.Combobox(
            top,
            textvariable=self.month_department_var,
            width=16,
            state="readonly",
            values=VIEW_DEPARTMENTS
        )
        self.month_department_combo.grid(row=0, column=7, sticky="w", padx=(8, 0))
        self.month_department_combo.bind("<<ComboboxSelected>>", lambda e: self.load_month_view())

        table_frame = ttk.Frame(root, padding=(16, 10))
        table_frame.grid(row=2, column=0, sticky="nsew", padx=18, pady=(0, 12))
        table_frame.rowconfigure(0, weight=1)
        table_frame.columnconfigure(0, weight=1)

        # Start with minimal columns, will rebuild dynamically
        self.month_tree = ttk.Treeview(table_frame, columns=("PMNo", "MachineName", "Department"), show="headings")
        self.month_tree.grid(row=0, column=0, sticky="nsew")

        ms = ttk.Scrollbar(table_frame, orient="vertical", command=self.month_tree.yview)
        self.month_tree.configure(yscrollcommand=ms.set)
        ms.grid(row=0, column=1, sticky="ns")

        hs = ttk.Scrollbar(table_frame, orient="horizontal", command=self.month_tree.xview)
        self.month_tree.configure(xscrollcommand=hs.set)
        hs.grid(row=1, column=0, sticky="ew")

    def refresh_month_options(self):
        months = list_report_months()
        self.month_combo["values"] = months if months else []
        if months and self.month_var.get() not in months:
            self.month_var.set(months[-1])

    def clear_month_table(self):
        for item in self.month_tree.get_children():
            self.month_tree.delete(item)

    def rebuild_month_tree_columns(self, columns):
        self.month_tree["columns"] = columns

        for c in columns:
            # Better header text
            header_text = "Machine Name" if c == "MachineName" else ("PM No" if c == "PMNo" else c)
            self.month_tree.heading(c, text=header_text)

            if c == "MachineName":
                self.month_tree.column(c, width=520, minwidth=360, anchor="w", stretch=True)
            elif c == "Department":
                self.month_tree.column(c, width=180, minwidth=130, anchor="w", stretch=False)
            elif c == "PMNo":
                self.month_tree.column(c, width=100, minwidth=80, anchor="w", stretch=False)
            elif re.match(r"^\d{4}-\d{2}-\d{2}$", str(c)):
                self.month_tree.column(c, width=100, minwidth=80, anchor="center", stretch=False)
            else:
                self.month_tree.column(c, width=130, minwidth=100, anchor="center", stretch=False)

    def load_month_view(self):
        try:
            month = safe_month_str(self.month_var.get())
        except Exception as e:
            self.set_status(f"Error: {e}", ok=False)
            return

        try:
            mode = "readings" if self.month_view_var.get() == "Readings" else "daily_use"
            df = build_monthly_detail_df(month, mode=mode)
        except Exception as e:
            self.set_status(f"Error: {e}", ok=False)
            self.clear_month_table()
            return

        department = (self.month_department_var.get() or "All").strip()
        if department and department != "All":
            df = df[df["Department"] == department]

        cols = list(df.columns)
        self.rebuild_month_tree_columns(cols)
        self.clear_month_table()

        num_cols = set(cols) - {"PMNo", "MachineName", "Department"}
        for _, r in df.iterrows():
            row_vals = []
            for c in cols:
                v = r.get(c, "")
                if c in num_cols:
                    row_vals.append(self.fmt4(v))
                else:
                    row_vals.append(v if v is not None else "")
            self.month_tree.insert("", tk.END, values=row_vals)

        filter_label = department if department else "All"
        self.set_status(
            f"Loaded ✓ | Month: {month} | View: {self.month_view_var.get()} | Department: {filter_label} | Machines: {len(df)}",
            ok=True
        )
        self.on_generate_monthly()

    def on_generate_monthly(self):
        try:
            month = safe_month_str(self.month_var.get())
            df_r = build_monthly_detail_df(month, mode="readings")
            df_u = build_monthly_detail_df(month, mode="daily_use")
            write_monthly_report(month, df_r, df_u)
            self.set_status(f"Monthly report created ✓ | {month} (Readings + Daily_Use sheets)", ok=True)
        except Exception as e:
            self.set_status(f"Error: {e}", ok=False)
            messagebox.showerror("Error", str(e))


if __name__ == "__main__":
    app = App()
    app.mainloop()

